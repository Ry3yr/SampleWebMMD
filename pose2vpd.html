<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>MMD 3D Pose Editor</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
    }
    canvas { 
      display: block; 
      cursor: grab;
      touch-action: none;
    }
    canvas.orb-dragging {
      cursor: grabbing !important;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(25, 25, 35, 0.85);
      color: white;
      padding: 20px;
      border-radius: 12px;
      width: 280px;
      z-index: 100;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    #ui h2 {
      margin-top: 0;
      color: #6c63ff;
      text-align: center;
      font-weight: 600;
      font-size: 1.4em;
      margin-bottom: 20px;
    }
    button {
      width: 100%;
      padding: 12px;
      margin-bottom: 12px;
      border-radius: 6px;
      border: none;
      background: linear-gradient(135deg, #6c63ff 0%, #4a44b5 100%);
      color: white;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      min-height: 44px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(108, 99, 255, 0.4);
    }
    #reset-btn {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
    }
    #reset-btn:hover {
      box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
    }
    #instructions {
      font-size: 12px;
      color: #8888aa;
      margin-top: 15px;
      line-height: 1.5;
      text-align: center;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      z-index: 100;
      background: rgba(25, 25, 35, 0.9);
      padding: 20px 30px;
      border-radius: 10px;
      text-align: center;
    }
    .footer {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
      font-size: 11px;
      color: #666;
    }
    .camera-controls {
      margin-top: 15px;
      padding: 15px;
      background: rgba(42, 42, 58, 0.5);
      border-radius: 8px;
    }
    .control-hint {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 11px;
    }
    .control-key {
      background: rgba(108, 99, 255, 0.3);
      padding: 2px 6px;
      border-radius: 3px;
    }
    #axis-controls {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 200;
    }
    .axis-btn {
      position: absolute;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: none;
      color: white;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      touch-action: manipulation;
    }
    .axis-btn:hover {
      transform: scale(1.2);
    }
    #x-plus { background: #ff4444; top: -60px; left: 0; }
    #x-minus { background: #ff4444; top: 60px; left: 0; }
    #y-plus { background: #44ff44; top: 0; left: -60px; }
    #y-minus { background: #44ff44; top: 0; left: 60px; }
    #z-plus { background: #4444ff; top: -40px; left: -40px; }
    #z-minus { background: #4444ff; top: 40px; left: 40px; }
    .mode-toggle {
      display: flex;
      margin-bottom: 15px;
      border-radius: 6px;
      overflow: hidden;
      background: rgba(42, 42, 58, 0.5);
    }
    .mode-btn {
      flex: 1;
      padding: 10px;
      background: transparent;
      border: none;
      color: #8888aa;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      min-height: auto;
    }
    .mode-btn.active {
      background: #6c63ff;
      color: white;
    }
    #control-mode-indicator {
      text-align: center;
      margin-top: 10px;
      font-size: 12px;
      color: #a0a0c0;
    }
    .storage-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
    }
    .storage-buttons button {
      flex: 1;
      margin-bottom: 0;
    }
    #stor1-btn {
      background: linear-gradient(135deg, #ffa726 0%, #f57c00 100%);
    }
    #stor2-btn {
      background: linear-gradient(135deg, #66bb6a 0%, #388e3c 100%);
    }
    #load-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
    }
    #load-buttons button {
      flex: 1;
      margin-bottom: 0;
    }
    #load1-btn {
      background: linear-gradient(135deg, #ffb74d 0%, #ff9800 100%);
    }
    #load2-btn {
      background: linear-gradient(135deg, #81c784 0%, #4caf50 100%);
    }
    #export-btn {
      background: linear-gradient(135deg, #ab47bc 0%, #8e24aa 100%);
    }
    #export-btn:hover {
      box-shadow: 0 4px 12px rgba(171, 71, 188, 0.4);
    }
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(25, 25, 35, 0.95);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      border-left: 4px solid #6c63ff;
      z-index: 1000;
      transform: translateX(400px);
      transition: transform 0.3s ease;
      backdrop-filter: blur(10px);
      max-width: 300px;
    }
    .notification.show {
      transform: translateX(0);
    }
    .mobile-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 50;
    }
    .mobile-control-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      background: rgba(108, 99, 255, 0.8);
      color: white;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      touch-action: manipulation;
    }
    #mobile-ui-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      background: rgba(25, 25, 35, 0.8);
      color: white;
      font-size: 20px;
      z-index: 101;
      backdrop-filter: blur(10px);
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    @media (max-width: 768px) {
      #ui {
        width: calc(100% - 40px);
        max-height: 70vh;
        overflow-y: auto;
      }
      #mobile-ui-toggle {
        display: flex;
      }
      .mobile-controls {
        display: flex;
      }
    }
  </style>

  <script src="./libs/three.js"></script>
  <script src="./libs/mmdparser.min.js"></script>
  <script src="./libs/ammo.min.js"></script>
  <script src="./libs/TGALoader.js"></script>
  <script src="./libs/CCDIKSolver.js"></script>
  <script src="./libs/MMDLoader.js"></script>
  <script src="./libs/MMDAnimationHelper.js"></script>
</head>
<body>
  <div id="loading">
    <div>Loading MMD Model...</div>
    <div style="margin-top:10px;font-size:14px;" id="loading-progress">0%</div>
  </div>
  
  <button id="mobile-ui-toggle">☰</button>
  
  <div id="ui" style="display: none;">
    <h2>MMD 3D Pose Editor</h2>
    
    <div class="mode-toggle">
      <button class="mode-btn active" id="rotation-mode">Rotation</button>
      <button class="mode-btn" id="position-mode">Position</button>
    </div>
    
    <button id="reset-btn">Reset All Poses</button>
    
    <div class="storage-buttons">
      <button id="stor1-btn">Store Pose 1</button>
      <button id="stor2-btn">Store Pose 2</button>
    </div>
    
    <div id="load-buttons">
      <button id="load1-btn">Load Pose 1</button>
      <button id="load2-btn">Load Pose 2</button>
    </div>
    
    <button id="export-btn">Export as VPD</button>
    
    <div id="control-mode-indicator">Current Mode: Rotation</div>
    
    <div class="camera-controls">
      <div style="text-align: center; margin-bottom: 10px; color: #a0a0c0; font-weight: 500;">Camera Controls</div>
      <div class="control-hint">
        <span>Orbit Camera:</span>
        <span class="control-key">Right Drag</span>
      </div>
      <div class="control-hint">
        <span>Zoom:</span>
        <span class="control-key">Scroll Wheel</span>
      </div>
      <div class="control-hint">
        <span>Pan:</span>
        <span class="control-key">Middle Drag</span>
      </div>
      <div class="control-hint">
        <span>Reset Camera:</span>
        <span class="control-key">Double Click</span>
      </div>
    </div>
    
    <div id="instructions">
      <p>Click and drag the colored orbs to pose the model</p>
      <p>Red: Rotation • Green: Position • Blue: Special</p>
      <p><strong>Left Click:</strong> Drag Orbs • <strong>Right Click:</strong> Orbit Camera</p>
      <p><strong>Click Orb:</strong> Show Axis Controls</p>
    </div>
    
    <div class="footer">
      <span>Magic Pose Editor</span>
      <span>v1.2</span>
    </div>
  </div>

  <div id="axis-controls">
    <button class="axis-btn" id="x-plus">X+</button>
    <button class="axis-btn" id="x-minus">X-</button>
    <button class="axis-btn" id="y-plus">Y+</button>
    <button class="axis-btn" id="y-minus">Y-</button>
    <button class="axis-btn" id="z-plus">Z+</button>
    <button class="axis-btn" id="z-minus">Z-</button>
  </div>

  <div class="mobile-controls">
    <button class="mobile-control-btn" id="mobile-orbit">🔄</button>
    <button class="mobile-control-btn" id="mobile-zoom-in">+</button>
    <button class="mobile-control-btn" id="mobile-zoom-out">-</button>
    <button class="mobile-control-btn" id="mobile-reset-cam">📷</button>
  </div>

  <div id="notification" class="notification"></div>

<script>
// Mobile detection and variables
let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
let touchStartTime = 0;
let lastTouchX = 0;
let lastTouchY = 0;
let isTouchOrbiting = false;
let isTouchDraggingOrb = false;
let touchOrbStartTime = 0;
let touchOrb = null;

let scene, camera, renderer, helper, model;
let boneOrbs = [];
let raycaster, mouse;
let isDraggingOrb = false;
let currentOrb = null;
let orbGroup;
let controls;
let axisControls;
let selectedOrb = null;
let controlMode = 'rotation'; // 'rotation' or 'position'

const ESSENTIAL_BONES = {
  '頭': 'head',
  '首': 'neck',
  '左腕': 'left_arm',
  '右腕': 'right_arm',
  '左ひじ': 'left_elbow', 
  '右ひじ': 'right_elbow',
  '左手首': 'left_wrist',
  '右手首': 'right_wrist',
  '左足': 'left_leg_upper',
  '右足': 'right_leg_upper',
  '左ひざ': 'left_knee',
  '右ひざ': 'right_knee',
  '左足首': 'left_ankle',
  '右足首': 'right_ankle',
  '左目': 'left_eye',
  '右目': 'right_eye'
};

function radToDeg(radians) {
  return radians * (180 / Math.PI);
}

function degToRad(degrees) {
  return degrees * (Math.PI / 180);
}

function showNotification(message, duration = 3000) {
  const notification = document.getElementById('notification');
  notification.textContent = message;
  notification.classList.add('show');
  
  setTimeout(() => {
    notification.classList.remove('show');
  }, duration);
}

class SimpleOrbitControls {
  constructor(camera, domElement) {
    this.camera = camera;
    this.domElement = domElement;
    
    this.enabled = true;
    this.target = new THREE.Vector3(0, 10, 0);
    this.minDistance = 5;
    this.maxDistance = 100;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    
    this.spherical = new THREE.Spherical().setFromVector3(
      new THREE.Vector3().subVectors(camera.position, this.target)
    );
    this.sphericalDelta = new THREE.Spherical();
    this.scale = 1;
    this.panOffset = new THREE.Vector3();
    this.zoomChanged = false;
    
    this.mouseButtons = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
    this.state = -1;
    
    this.domElement.addEventListener('contextmenu', this.onContextMenu.bind(this));
    this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
    this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
    this.domElement.addEventListener('dblclick', this.onDoubleClick.bind(this));
    
    // Touch events for mobile
    this.domElement.addEventListener('touchstart', this.onTouchStart.bind(this));
    this.domElement.addEventListener('touchmove', this.onTouchMove.bind(this));
    this.domElement.addEventListener('touchend', this.onTouchEnd.bind(this));
    
    this.update();
  }
  
  onContextMenu(event) {
    event.preventDefault();
  }
  
  onMouseDown(event) {
    if (!this.enabled) return;
    
    if (event.button !== this.mouseButtons.RIGHT && event.button !== this.mouseButtons.MIDDLE) {
      return;
    }
    
    event.preventDefault();
    
    switch (event.button) {
      case this.mouseButtons.RIGHT:
        this.state = 0;
        break;
      case this.mouseButtons.MIDDLE:
        this.state = 2;
        break;
    }
    
    if (this.state !== -1) {
      document.addEventListener('mousemove', this.onMouseMove.bind(this));
      document.addEventListener('mouseup', this.onMouseUp.bind(this));
    }
  }
  
  onMouseMove(event) {
    if (!this.enabled) return;
    
    event.preventDefault();
    
    const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
    const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
    
    if (this.state === 0) {
      this.sphericalDelta.theta -= movementX * 0.01;
      this.sphericalDelta.phi -= movementY * 0.01;
    } else if (this.state === 2) {
      this.panOffset.x -= movementX * 0.01;
      this.panOffset.y += movementY * 0.01;
    }
  }
  
  onMouseUp() {
    this.state = -1;
    document.removeEventListener('mousemove', this.onMouseMove);
    document.removeEventListener('mouseup', this.onMouseUp);
  }
  
  onMouseWheel(event) {
    if (!this.enabled) return;
    
    event.preventDefault();
    
    if (event.deltaY < 0) {
      this.scale /= 1.1;
    } else if (event.deltaY > 0) {
      this.scale *= 1.1;
    }
    
    this.zoomChanged = true;
  }
  
  onDoubleClick() {
    this.target.set(0, 10, 0);
    this.spherical.set(1, Math.PI / 2, 0);
    this.spherical.radius = 45;
    this.sphericalDelta.set(0, 0, 0);
    this.panOffset.set(0, 0, 0);
    this.scale = 1;
    this.update();
  }
  
  // Touch event handlers for mobile
  onTouchStart(event) {
    if (!this.enabled || event.touches.length !== 1) return;
    
    event.preventDefault();
    
    const touch = event.touches[0];
    lastTouchX = touch.clientX;
    lastTouchY = touch.clientY;
    touchStartTime = Date.now();
    
    // Check if we're touching an orb (will be handled separately)
    const mouse = new THREE.Vector2(
      (touch.clientX / window.innerWidth) * 2 - 1,
      -(touch.clientY / window.innerHeight) * 2 + 1
    );
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(boneOrbs);
    
    if (intersects.length > 0) {
      // Orb touch - let the orb handler deal with it
      return;
    }
    
    // Otherwise, start orbit camera
    isTouchOrbiting = true;
    this.state = 0;
  }
  
  onTouchMove(event) {
    if (!this.enabled || !isTouchOrbiting || event.touches.length !== 1) return;
    
    event.preventDefault();
    
    const touch = event.touches[0];
    const deltaX = touch.clientX - lastTouchX;
    const deltaY = touch.clientY - lastTouchY;
    
    if (this.state === 0) {
      this.sphericalDelta.theta -= deltaX * 0.01;
      this.sphericalDelta.phi -= deltaY * 0.01;
    }
    
    lastTouchX = touch.clientX;
    lastTouchY = touch.clientY;
  }
  
  onTouchEnd(event) {
    if (isTouchOrbiting) {
      isTouchOrbiting = false;
      this.state = -1;
    }
  }
  
  update() {
    const offset = new THREE.Vector3();
    
    this.spherical.theta += this.sphericalDelta.theta;
    this.spherical.phi += this.sphericalDelta.phi;
    
    this.spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this.spherical.phi));
    
    if (this.zoomChanged) {
      this.spherical.radius *= this.scale;
      this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));
      this.scale = 1;
      this.zoomChanged = false;
    }
    
    this.target.add(this.panOffset);
    this.panOffset.set(0, 0, 0);
    
    this.target.y = Math.max(0, Math.min(30, this.target.y));
    
    offset.setFromSpherical(this.spherical);
    this.camera.position.copy(this.target).add(offset);
    this.camera.lookAt(this.target);
    
    this.sphericalDelta.set(0, 0, 0);
  }
}

init();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1a1a2e);

  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
  camera.position.set(0, 15, 45);

  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambient);

  const light = new THREE.DirectionalLight(0xffffff, 0.8);
  light.position.set(0, 20, 10);
  scene.add(light);

  const rimLight = new THREE.DirectionalLight(0x4a44b5, 0.3);
  rimLight.position.set(0, 10, -20);
  scene.add(rimLight);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const groundGeometry = new THREE.PlaneGeometry(50, 50);
  const groundMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x2a2a3a, 
    roughness: 0.8,
    metalness: 0.2
  });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.1;
  scene.add(ground);

  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  orbGroup = new THREE.Group();
  scene.add(orbGroup);

  controls = new SimpleOrbitControls(camera, renderer.domElement);

  helper = new THREE.MMDAnimationHelper();

  const loader = new THREE.MMDLoader();

function getPMXPath() {
  const params = new URLSearchParams(window.location.search);
  const pmxParam = params.get('pmx');
  if (pmxParam) {
    // prepend folder path and decode URI safely
    return "pmx/pronama/" + decodeURIComponent(pmxParam);
  }
  return "pmx/pronama/YusakuFujiki/yusaku.pmx"; // default fallback
}

const modelPath = getPMXPath();

loader.load(
  modelPath,
    function (mesh) {
      model = mesh;
      model.position.y = 0;
      scene.add(model);

      document.getElementById('loading').style.display = 'none';
      document.getElementById('ui').style.display = 'block';
      
      // Show mobile UI toggle on mobile
      if (isMobile) {
        document.getElementById('mobile-ui-toggle').style.display = 'flex';
        // Hide UI by default on mobile to maximize canvas space
        document.getElementById('ui').style.display = 'none';
      }
      
    model.updateMatrixWorld(true);
    model.skeleton.bones.forEach(bone => {
      bone.userData.bindQuaternion = bone.quaternion.clone();
    });
      createAllOrbControls();
      
      setupUI();
      
      setupOrbInteraction();
      
      setupAxisControls();
      
      setupMobileControls();
      
      animate();
    },
    function (xhr) {
      if (xhr.lengthComputable) {
        const percentComplete = (xhr.loaded / xhr.total * 100).toFixed(0);
        document.getElementById('loading-progress').textContent = `${percentComplete}%`;
      }
    },
    function (error) {
      console.error("Error loading model:", error);
      document.getElementById('loading').innerHTML = `
        <div style="color:#ff6b6b">Error loading model</div>
        <div style="margin-top:10px;font-size:14px;">Check browser console for details</div>
        <button onclick="location.reload()" style="margin-top:15px;padding:8px 15px;background:#6c63ff;border:none;border-radius:4px;color:white;cursor:pointer;">Retry</button>
      `;
    }
  );

  window.addEventListener("resize", onWindowResize);
}

function setupMobileControls() {
  const orbitBtn = document.getElementById('mobile-orbit');
  const zoomInBtn = document.getElementById('mobile-zoom-in');
  const zoomOutBtn = document.getElementById('mobile-zoom-out');
  const resetCamBtn = document.getElementById('mobile-reset-cam');
  const uiToggle = document.getElementById('mobile-ui-toggle');
  
  orbitBtn.addEventListener('click', function() {
    showNotification('Drag with one finger to orbit camera');
  });
  
  zoomInBtn.addEventListener('click', function() {
    controls.scale /= 1.2;
    controls.zoomChanged = true;
  });
  
  zoomOutBtn.addEventListener('click', function() {
    controls.scale *= 1.2;
    controls.zoomChanged = true;
  });
  
  resetCamBtn.addEventListener('click', function() {
    controls.onDoubleClick();
    showNotification('Camera reset');
  });
  
  uiToggle.addEventListener('click', function() {
    const ui = document.getElementById('ui');
    if (ui.style.display === 'none') {
      ui.style.display = 'block';
    } else {
      ui.style.display = 'none';
    }
  });
}

function createAllOrbControls() {
  orbGroup.children = [];
  boneOrbs = [];

  if (!model || !model.skeleton) return;

  const bones = model.skeleton.bones;

  Object.keys(ESSENTIAL_BONES).forEach(japaneseName => {
    const bone = bones.find(b => b.name === japaneseName);
    if (bone) {
      createOrbForBone(bone, ESSENTIAL_BONES[japaneseName]);
    }
  });

  console.log(`Created ${boneOrbs.length} orbs for essential bones`);
}

function createOrbForBone(bone, englishName) {
  const boneWorldPos = new THREE.Vector3();
  bone.getWorldPosition(boneWorldPos);

  const orbGeometry = new THREE.SphereGeometry(0.8, 16, 16);
  
  let orbColor;
  if (englishName.includes('eye')) {
    orbColor = 0x6b6bff;
  } else if (englishName.includes('wrist') || englishName.includes('ankle')) {
    orbColor = 0x6bff6b;
  } else {
    orbColor = 0xff6b6b;
  }

  const orbMaterial = new THREE.MeshBasicMaterial({ 
    color: orbColor,
    transparent: true,
    opacity: englishName.includes('eye') ? 0.5 : 0.9
  });
  
  const orb = new THREE.Mesh(orbGeometry, orbMaterial);
  orb.position.copy(boneWorldPos);
  orb.userData = { 
    type: 'bone_control', 
    bone: bone, 
    boneName: englishName,
    originalPosition: boneWorldPos.clone()
  };
  
  orbGroup.add(orb);
  boneOrbs.push(orb);
}

function setupOrbInteraction() {
  renderer.domElement.addEventListener('mousedown', onMouseDown);
  renderer.domElement.addEventListener('mousemove', onMouseMove);
  renderer.domElement.addEventListener('mouseup', onMouseUp);
  renderer.domElement.addEventListener('click', onOrbClick);
  
  // Touch events for mobile orb interaction
  renderer.domElement.addEventListener('touchstart', onTouchStartOrb, { passive: false });
  renderer.domElement.addEventListener('touchmove', onTouchMoveOrb, { passive: false });
  renderer.domElement.addEventListener('touchend', onTouchEndOrb);
}

function onTouchStartOrb(event) {
  if (event.touches.length !== 1) return;
  
  event.preventDefault();
  
  const touch = event.touches[0];
  mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  
  const intersects = raycaster.intersectObjects(boneOrbs);
  
  if (intersects.length > 0) {
    isTouchDraggingOrb = true;
    touchOrb = intersects[0].object;
    touchOrbStartTime = Date.now();
    lastTouchX = touch.clientX;
    lastTouchY = touch.clientY;
    
    // Show axis controls on long press (for mobile)
    setTimeout(() => {
      if (isTouchDraggingOrb && touchOrb && Date.now() - touchOrbStartTime > 500) {
        showAxisControls(touchOrb);
      }
    }, 500);
  }
}

function onTouchMoveOrb(event) {
  if (!isTouchDraggingOrb || !touchOrb || event.touches.length !== 1) return;
  
  event.preventDefault();
  
  const touch = event.touches[0];
  const deltaX = touch.clientX - lastTouchX;
  const deltaY = touch.clientY - lastTouchY;
  
  const bone = touchOrb.userData.bone;
  const boneName = touchOrb.userData.boneName;
  
  if (controlMode === 'rotation') {
    // Rotation mode
    if (boneName.includes('eye')) {
      bone.rotation.y += deltaX * 0.01;
      bone.rotation.x += deltaY * 0.01;
    } else {
      bone.rotation.y += deltaX * 0.02;
      bone.rotation.x += deltaY * 0.02;
    }
    
    bone.rotation.x = Math.max(-Math.PI, Math.min(Math.PI, bone.rotation.x));
    bone.rotation.y = Math.max(-Math.PI, Math.min(Math.PI, bone.rotation.y));
    bone.rotation.z = Math.max(-Math.PI, Math.min(Math.PI, bone.rotation.z));
  } else {
    // Position mode
    if (boneName.includes('wrist') || boneName.includes('ankle') || boneName.includes('eye')) {
      bone.position.x += deltaX * 0.05;
      bone.position.y -= deltaY * 0.05;
    }
  }
  
  bone.updateMatrixWorld(true);
  updateOrbPositions();
  
  lastTouchX = touch.clientX;
  lastTouchY = touch.clientY;
}

function onTouchEndOrb(event) {
  if (isTouchDraggingOrb) {
    // Check if it was a tap (not a drag) to show axis controls
    if (touchOrb && Date.now() - touchOrbStartTime < 300) {
      showAxisControls(touchOrb);
    }
    
    isTouchDraggingOrb = false;
    touchOrb = null;
  }
}

function onOrbClick(event) {
  if (event.button !== 0) return;
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  
  const intersects = raycaster.intersectObjects(boneOrbs);
  
  if (intersects.length > 0) {
    const clickedOrb = intersects[0].object;
    showAxisControls(clickedOrb);
    event.stopPropagation();
  } else {
    hideAxisControls();
  }
}

function showAxisControls(orb) {
  selectedOrb = orb;
  const axisControls = document.getElementById('axis-controls');
  axisControls.style.display = 'block';
  
  const screenPosition = new THREE.Vector3();
  orb.getWorldPosition(screenPosition);
  screenPosition.project(camera);
  
  const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
  const y = -(screenPosition.y * 0.5 - 0.5) * window.innerHeight;
  
  axisControls.style.left = x + 'px';
  axisControls.style.top = y + 'px';
}

function hideAxisControls() {
  selectedOrb = null;
  document.getElementById('axis-controls').style.display = 'none';
}

function setupAxisControls() {
  document.getElementById('x-plus').addEventListener('click', () => moveBoneOnAxis('x', 1));
  document.getElementById('x-minus').addEventListener('click', () => moveBoneOnAxis('x', -1));
  document.getElementById('y-plus').addEventListener('click', () => moveBoneOnAxis('y', 1));
  document.getElementById('y-minus').addEventListener('click', () => moveBoneOnAxis('y', -1));
  document.getElementById('z-plus').addEventListener('click', () => moveBoneOnAxis('z', 1));
  document.getElementById('z-minus').addEventListener('click', () => moveBoneOnAxis('z', -1));
  
  // Add touch events for axis controls on mobile
  const axisButtons = document.querySelectorAll('.axis-btn');
  axisButtons.forEach(btn => {
    btn.addEventListener('touchstart', function(e) {
      e.preventDefault();
      this.click();
    }, { passive: false });
  });
}

function moveBoneOnAxis(axis, direction) {
  if (!selectedOrb) return;
  
  const bone = selectedOrb.userData.bone;
  const boneName = selectedOrb.userData.boneName;
  
  const rotationStep = isMobile ? 0.05 : 0.1;
  const positionStep = isMobile ? 0.25 : 0.5;
  
  if (controlMode === 'rotation') {
    // Rotation mode
    if (boneName.includes('eye')) {
      bone.rotation[axis] += direction * rotationStep * 0.1;
    } else {
      bone.rotation[axis] += direction * rotationStep;
    }
    
    bone.rotation.x = Math.max(-Math.PI, Math.min(Math.PI, bone.rotation.x));
    bone.rotation.y = Math.max(-Math.PI, Math.min(Math.PI, bone.rotation.y));
    bone.rotation.z = Math.max(-Math.PI, Math.min(Math.PI, bone.rotation.z));
  } else {
    // Position mode
    if (boneName.includes('wrist') || boneName.includes('ankle') || boneName.includes('eye')) {
      bone.position[axis] += direction * positionStep;
    }
  }
  
  bone.updateMatrixWorld(true);
  updateOrbPositions();
}

function onMouseDown(event) {
  if (event.button !== 0) return;
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  
  const intersects = raycaster.intersectObjects(boneOrbs);
  
  if (intersects.length > 0) {
    isDraggingOrb = true;
    currentOrb = intersects[0].object;
    renderer.domElement.classList.add('orb-dragging');
    document.body.style.cursor = 'grabbing';
    
    event.preventDefault();
    event.stopPropagation();
  }
}

function onMouseMove(event) {
  if (!isDraggingOrb || !currentOrb) return;
  
  const bone = currentOrb.userData.bone;
  const boneName = currentOrb.userData.boneName;
  
  const deltaX = event.movementX * 0.01;
  const deltaY = event.movementY * 0.01;
  
  if (controlMode === 'rotation') {
    // Rotation mode
    if (boneName.includes('eye')) {
      bone.rotation.y += deltaX * 0.1;
      bone.rotation.x += deltaY * 0.1;
    } else {
      bone.rotation.y += deltaX;
      bone.rotation.x += deltaY;
    }
    
    bone.rotation.x = Math.max(-Math.PI, Math.min(Math.PI, bone.rotation.x));
    bone.rotation.y = Math.max(-Math.PI, Math.min(Math.PI, bone.rotation.y));
    bone.rotation.z = Math.max(-Math.PI, Math.min(Math.PI, bone.rotation.z));
  } else {
    // Position mode
    if (boneName.includes('wrist') || boneName.includes('ankle') || boneName.includes('eye')) {
      bone.position.x += deltaX * 2;
      bone.position.y -= deltaY * 2;
    }
  }
  
  bone.updateMatrixWorld(true);
  updateOrbPositions();
}

function onMouseUp(event) {
  if (event.button === 0 && isDraggingOrb) {
    isDraggingOrb = false;
    currentOrb = null;
    renderer.domElement.classList.remove('orb-dragging');
    document.body.style.cursor = 'default';
  }
}

function updateOrbPositions() {
  boneOrbs.forEach(orb => {
    const bone = orb.userData.bone;
    const boneWorldPos = new THREE.Vector3();
    bone.getWorldPosition(boneWorldPos);
    orb.position.copy(boneWorldPos);
  });
}


function getCurrentPose() {
  if (!model || !model.skeleton) return {};
  const pose = {};
  const bones = model.skeleton.bones;

  model.updateMatrixWorld(true);

  Object.keys(ESSENTIAL_BONES).forEach(japaneseName => {
    const bone = bones.find(b => b.name === japaneseName);
    if (!bone) return;

    const bindQuat = bone.userData?.bindQuaternion
      ? bone.userData.bindQuaternion.clone()
      : new THREE.Quaternion(); // fallback identity

    // relative rotation: bind^-1 * current
    const invBind = bindQuat.clone();
    if (typeof invBind.invert === "function") invBind.invert();
    else invBind.inverse();

    const relativeQuat = invBind.multiply(bone.quaternion).normalize();

    pose[japaneseName] = {
      quaternion: {
        x: relativeQuat.x,
        y: relativeQuat.y,
        z: relativeQuat.z,
        w: relativeQuat.w
      }
    };
  });

  return pose;
}

// Apply a portable pose (rotation only)
function applyPose(pose) {
  if (!model || !model.skeleton) return;
  const bones = model.skeleton.bones;

  model.updateMatrixWorld(true);

  Object.keys(pose).forEach(japaneseName => {
    const bone = bones.find(b => b.name === japaneseName);
    if (!bone || !pose[japaneseName]) return;

    const relQuat = new THREE.Quaternion(
      pose[japaneseName].quaternion.x,
      pose[japaneseName].quaternion.y,
      pose[japaneseName].quaternion.z,
      pose[japaneseName].quaternion.w
    );

    const bindQuat = bone.userData?.bindQuaternion
      ? bone.userData.bindQuaternion.clone()
      : new THREE.Quaternion();

    bone.quaternion.copy(bindQuat.clone().multiply(relQuat).normalize());
    bone.updateMatrixWorld(true);
  });

  model.skeleton.update();
  updateOrbPositions();
}


function exportToVPD() {
  if (!model || !model.skeleton) return;

  const bones = model.skeleton.bones;
  let vpdContent = "Vocaloid Pose Data file\r\n\r\n0;\r\n\r\n";
  const exportBones = [];

  // Update all matrices first
  model.updateMatrixWorld(true);

  Object.keys(ESSENTIAL_BONES).forEach(japaneseName => {
    const bone = bones.find(b => b.name === japaneseName);
    if (!bone) return;

    // Get current bone quaternion
    const currentQuat = bone.quaternion.clone();

    // Get bind pose quaternion (store once on load)
    const bindQuat = bone.userData?.bindQuaternion
      ? bone.userData.bindQuaternion.clone()
      : new THREE.Quaternion(); // default identity if missing

    // Compute relative rotation (Three.js < r150 uses inverse())
    const invBind = bindQuat.clone();
    if (typeof invBind.invert === "function") {
      invBind.invert();
    } else {
      invBind.inverse();
    }

    const relativeQuat = invBind.multiply(currentQuat);
    relativeQuat.normalize();

    const rotationThreshold = 0.0001;
    const hasRotation =
      Math.abs(relativeQuat.x) > rotationThreshold ||
      Math.abs(relativeQuat.y) > rotationThreshold ||
      Math.abs(relativeQuat.z) > rotationThreshold ||
      Math.abs(relativeQuat.w - 1) > rotationThreshold;

    if (hasRotation) {
      exportBones.push({
        name: japaneseName,
        quaternion: relativeQuat,
        index: exportBones.length
      });
    }
  });

  // Update bone count
  vpdContent = vpdContent.replace("0;\r\n\r\n", `${exportBones.length};\r\n\r\n`);

  exportBones.forEach(boneData => {
    vpdContent += `Bone${boneData.index}{${boneData.name}\r\n`;
    vpdContent += "  0.000000,0.000000,0.000000;\r\n";

    // Convert to MMD quaternion (flip handedness only)
    const q = boneData.quaternion;
    const mmdQuat = new THREE.Quaternion(-q.x, q.z, q.y, -q.w);
    mmdQuat.normalize();

    vpdContent += `  ${mmdQuat.x.toFixed(6)},${mmdQuat.y.toFixed(6)},${mmdQuat.z.toFixed(6)},${mmdQuat.w.toFixed(6)};\r\n`;
    vpdContent += "}\r\n";
  });

  // Save file
  const BOM = '\uFEFF';
  const blob = new Blob([BOM + vpdContent], { type: 'text/plain; charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'pose.vpd';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  showNotification(`VPD exported! ${exportBones.length} modified bones.`);

  console.log("VPD Content:\n", vpdContent);
  console.log("Exported relative bone rotations:");
  exportBones.forEach(boneData => {
    console.log(boneData.name, boneData.quaternion);
  });
}



function setupUI() {
  const resetBtn = document.getElementById('reset-btn');
  const exportBtn = document.getElementById('export-btn');
  const rotationModeBtn = document.getElementById('rotation-mode');
  const positionModeBtn = document.getElementById('position-mode');
  const modeIndicator = document.getElementById('control-mode-indicator');
  const stor1Btn = document.getElementById('stor1-btn');
  const stor2Btn = document.getElementById('stor2-btn');
  const load1Btn = document.getElementById('load1-btn');
  const load2Btn = document.getElementById('load2-btn');
  
  // Make buttons touch-friendly on mobile
  if (isMobile) {
    const buttons = document.querySelectorAll('button');
    buttons.forEach(btn => {
      btn.addEventListener('touchstart', function(e) {
        e.preventDefault();
        this.click();
      }, { passive: false });
    });
  }
  
  resetBtn.addEventListener('click', function() {
    if (model && model.skeleton) {
      const bones = model.skeleton.bones;
      bones.forEach(bone => {
        bone.rotation.set(0, 0, 0);
        bone.position.set(0, 0, 0);
      });
      model.skeleton.update();
      updateOrbPositions();
      hideAxisControls();
      showNotification('Pose reset to default');
    }
  });
  
  exportBtn.addEventListener('click', exportToVPD);
  
  rotationModeBtn.addEventListener('click', function() {
    controlMode = 'rotation';
    rotationModeBtn.classList.add('active');
    positionModeBtn.classList.remove('active');
    modeIndicator.textContent = 'Current Mode: Rotation';
  });
  
  positionModeBtn.addEventListener('click', function() {
    controlMode = 'position';
    positionModeBtn.classList.add('active');
    rotationModeBtn.classList.remove('active');
    modeIndicator.textContent = 'Current Mode: Position';
  });
  
  stor1Btn.addEventListener('click', function() {
    const pose = getCurrentPose();
    localStorage.setItem('stor1', JSON.stringify(pose));
    showNotification('Pose saved to Slot 1');
  });
  
  stor2Btn.addEventListener('click', function() {
    const pose = getCurrentPose();
    localStorage.setItem('stor2', JSON.stringify(pose));
    showNotification('Pose saved to Slot 2');
  });
  
load1Btn.addEventListener('click', function() {
  const storedPose = localStorage.getItem('stor1');
  if (storedPose) {
    const pose = JSON.parse(storedPose);
    console.log('Loaded from Slot 1:', pose);
    applyPose(pose);
    showNotification('Pose loaded from Slot 1');
  } else {
    console.log('No pose found in Slot 1');
    showNotification('No pose found in Slot 1', 2000);
  }
});

load2Btn.addEventListener('click', function() {
  const storedPose = localStorage.getItem('stor2');
  if (storedPose) {
    const pose = JSON.parse(storedPose);
    console.log('Loaded from Slot 2:', pose);
    applyPose(pose);
    showNotification('Pose loaded from Slot 2');
  } else {
    console.log('No pose found in Slot 2');
    showNotification('No pose found in Slot 2', 2000);
  }
});
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  
  controls.update();
  
  if (!isDraggingOrb && !isTouchDraggingOrb) {
    updateOrbPositions();
  }
  
  renderer.render(scene, camera);
}
</script>
</body>
</html>